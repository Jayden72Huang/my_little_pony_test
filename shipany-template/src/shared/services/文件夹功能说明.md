# Services 目录说明

## 目录功能
业务服务层（Service Layer）

## 目录目的
封装复杂的业务逻辑和第三方服务集成，提供高层次的业务功能接口，是 Model 层和 Controller 层之间的桥梁

## 文件列表

### 支付与交易相关
- **payment.ts** - 支付服务管理
  - 功能：集成多种支付提供商（Stripe、PayPal、Creem），处理支付会话、订单创建、订阅管理
  - 目的：统一支付接口，支持多支付渠道切换和订单处理流程

- **affiliate.ts** - 联盟营销服务
  - 功能：管理推广联盟、佣金计算、推荐关系追踪
  - 目的：实现推荐营销和佣金分成机制

### AI 相关服务
- **ai.ts** - AI 服务集成
  - 功能：集成 AI 模型提供商（OpenAI、Claude 等），处理 AI 任务调用
  - 目的：统一 AI 服务接口，支持多 AI 提供商切换

### 存储与邮件服务
- **storage.ts** - 云存储服务管理
  - 功能：集成对象存储服务（S3、Cloudflare R2），处理文件上传、下载、删除
  - 目的：统一存储接口，支持多云存储提供商

- **email.ts** - 邮件服务管理
  - 功能：集成邮件发送服务（Resend），发送交易邮件、通知邮件
  - 目的：统一邮件发送接口，支持多邮件提供商

### 分析与营销
- **analytics.ts** - 数据分析服务
  - 功能：集成数据分析工具（Google Analytics、Plausible 等），追踪用户行为
  - 目的：统一数据埋点和分析接口

- **ads.ts** - 广告服务管理
  - 功能：集成广告平台（Google Ads、Facebook Ads 等），管理广告投放
  - 目的：统一广告投放和转化追踪

### 用户与权限
- **rbac.ts** - 基于角色的访问控制（Role-Based Access Control）
  - 功能：角色管理、权限管理、用户权限验证
  - 目的：实现细粒度的权限控制系统

- **customer_service.tsx** - 客户服务集成
  - 功能：集成客服系统（在线聊天、工单系统等）
  - 目的：提供客户支持和服务功能

### 系统配置
- **settings.ts** - 系统设置服务
  - 功能：读取和管理系统配置、应用设置
  - 目的：提供统一的配置管理接口

## 架构说明

### 设计模式
采用 **服务层模式（Service Layer Pattern）**，是经典三层架构的中间层

### 架构位置
```
Controller/API Layer (API Routes, Server Actions)
           ↓
    Service Layer (services/) ← 当前目录
           ↓
     Model Layer (models/)
           ↓
      Database Layer
```

### Service 层的典型结构

```typescript
// 1. 服务管理器初始化
export function getXxxServiceWithConfigs(configs: Configs) {
  const manager = new XxxManager();

  // 根据配置添加不同的提供商
  if (configs.provider_a_enabled) {
    manager.addProvider(new ProviderA(configs));
  }

  if (configs.provider_b_enabled) {
    manager.addProvider(new ProviderB(configs));
  }

  return manager;
}

// 2. 全局服务实例
let xxxService: XxxManager | null = null;

// 3. 获取服务实例（单例模式）
export async function getXxxService(configs?: Configs): Promise<XxxManager> {
  if (!configs) {
    configs = await getAllConfigs();
  }
  xxxService = getXxxServiceWithConfigs(configs);
  return xxxService;
}

// 4. 业务逻辑函数
export async function processXxxTask(params: XxxParams) {
  const service = await getXxxService();
  const result = await service.process(params);

  // 调用 model 层保存结果
  await createXxxRecord(result);

  return result;
}
```

### 关键特点

1. **第三方服务集成**
   - 封装外部 API 调用（支付、邮件、存储等）
   - 统一错误处理和重试逻辑

2. **多提供商支持**
   - 支持同时配置多个服务提供商
   - 运行时动态切换提供商

3. **配置驱动**
   - 基于数据库配置初始化服务
   - 无需重启即可更新服务配置

4. **业务编排**
   - 协调多个 Model 层操作
   - 处理跨模块的复杂业务逻辑

## 使用示例

### 示例 1: 使用支付服务
```typescript
import { getPaymentService } from '@/shared/services/payment';

// 创建支付会话
const paymentService = await getPaymentService();
const session = await paymentService.createPaymentSession({
  amount: 2999,
  currency: 'USD',
  productName: 'Premium Plan',
  userId: 'user-123'
});

// 返回支付链接给前端
return { checkoutUrl: session.url };
```

### 示例 2: 发送邮件
```typescript
import { getEmailService } from '@/shared/services/email';

const emailService = await getEmailService();
await emailService.send({
  to: 'user@example.com',
  subject: 'Welcome to Our Platform',
  html: '<h1>Welcome!</h1><p>Thank you for signing up.</p>'
});
```

### 示例 3: 上传文件到云存储
```typescript
import { getStorageService } from '@/shared/services/storage';

const storageService = await getStorageService();
const result = await storageService.upload({
  file: fileBuffer,
  fileName: 'avatar.jpg',
  folder: 'avatars',
  contentType: 'image/jpeg'
});

// 返回公开访问 URL
return { url: result.url };
```

### 示例 4: 权限验证
```typescript
import { checkUserPermission } from '@/shared/services/rbac';

// 检查用户是否有权限执行某操作
const hasPermission = await checkUserPermission(
  userId,
  'posts:delete'
);

if (!hasPermission) {
  throw new Error('Permission denied');
}
```

## Service vs Model 的区别

| 特性 | Model 层 | Service 层 |
|------|---------|-----------|
| **职责** | 数据访问 | 业务逻辑 |
| **操作对象** | 单个数据表 | 多个 Model、外部 API |
| **复杂度** | 简单的 CRUD | 复杂的业务流程 |
| **示例** | `createUser()` | `registerUserAndSendEmail()` |
| **依赖** | 只依赖数据库 | 依赖 Model 和外部服务 |

## 架构优势

✅ **关注点分离** - 业务逻辑与数据访问分离，代码更清晰
✅ **可测试性** - 易于编写单元测试和集成测试
✅ **可复用性** - Service 可在多个 API 路由中复用
✅ **易维护性** - 修改第三方服务只需更新 Service 层
✅ **灵活性** - 支持多提供商切换，降低供应商锁定风险
✅ **一致性** - 统一的错误处理和日志记录

## 最佳实践

1. **单一职责** - 每个 Service 文件只处理一类业务
2. **依赖注入** - 通过配置参数注入依赖，而非硬编码
3. **错误处理** - 统一捕获和转换第三方服务错误
4. **日志记录** - 记录关键操作和错误信息
5. **事务管理** - 涉及多个数据库操作时使用事务
6. **缓存策略** - 对频繁访问的配置数据进行缓存
7. **异步优先** - 使用 async/await 处理异步操作

## 注意事项

- 避免在 Service 层直接操作数据库，应通过 Model 层
- 第三方 API 调用应添加超时和重试机制
- 敏感配置（API Key）应通过环境变量或加密存储
- 定期检查第三方服务的 API 变更和弃用通知
